pipeline {
  agent {
    label "slurm"
  }
  parameters {
    listGitBranches(
      branchFilter: '.*',
      credentialsId: 'jenkins',
      defaultValue: '',
      name: 'BRANCH_TO_BUILD',
      quickFilterEnabled: false,
      remoteURL: 'ssh://git@stash.ihme.washington.edu:7999/scic/jobmon.git',
      selectedValue: 'DEFAULT',
      sortMode: 'NONE',
      tagFilter: '*',
      type: 'PT_BRANCH'
    )
    booleanParam(defaultValue: 'false',
      description: 'If true, Tests step will be skipped',
      name: 'SKIP_TESTS')
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '30'))
  } // End options
  environment {
    // Jenkins commands run in separate processes, so need to activate the environment to run nox.
    ACTIVATE = ". /homes/svcscicompci/miniconda3/bin/activate base"
    STASH_URL = "https://stash.ihme.washington.edu/scm/scic/jobmon.git"
  } // End environment
  stages {
    stage('Remote Checkout Repo') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: params.BRANCH_TO_BUILD]],
          userRemoteConfigs: scm.userRemoteConfigs
        ])
      } // End step
    } // End remote checkout repo stage
    stage('Tests') {
      steps {
        script {
          if (params.SKIP_TESTS) {
            echo "Skipping Tests"
          } else {
            sh "${ACTIVATE} && nox --session tests -- tests/ -n 3"
          }
        }
      }
      post {
        always {
          // Publish the coverage reports.
          publishHTML([
            allowMissing: true,
            alwaysLinkToLastBuild: false,
            keepAll: true,
            reportDir: '/out/coverage_html_report',
            reportFiles: 'index.html',
            reportName: 'Coverage Report',
            reportTitles: ''
          ])
          // Publish the test results
          junit([
            testResults: "/out/test_report.xml",
            allowEmptyResults: true
          ])
        } // End always
      } // End post
    } // End tests stage
    stage ('Build Python Distribution') {
      steps {
        script {
          def branch_sections = "${GIT_BRANCH}".split('/')
          env.BRANCH_TYPE = branch_sections[branch_sections.length-2]
          env.BRANCH_NAME = branch_sections[branch_sections.length-1]
          if (branch_type == 'release') {
            if (!("${BRANCH_NAME}" ==~ /\d+\.\d+\.\d+/)) {
              error("Branch Name ${BRANCH_NAME} is not a valid semver in complete major.minor.patch format. Build aborted!")
            }
            sh '''#!/bin/bash
                JOBMON_LAST_RC_TAG=$(git tag -l --sort=refname ${BRANCH_NAME}rc* | tail -1)
                echo "$JOBMON_LAST_RC_TAG" > $WORKSPACE/jobmon_last_rc_tag_${BUILD_NUMBER}.txt
               '''
            env.JOBMON_LAST_RC_TAG = sh (
              script: '''#!/bin/bash
                         cat ${WORKSPACE}/jobmon_last_rc_tag_${BUILD_NUMBER}.txt
                      ''',
              returnStdout: true
            ).trim()
            println "JOBMON_LAST_RC_TAG=${JOBMON_LAST_RC_TAG}"

            if ("${JOBMON_LAST_RC_TAG}" == '') {
              env.JOBMON_NEW_RC_TAG = "${BRANCH_NAME}rc1"
            } else {
              def last_number = "${JOBMON_LAST_RC_TAG}".substring("${BRANCH_NAME}rc".length())
              int intNum = last_number as int
              env.JOBMON_NEW_RC_TAG = "${BRANCH_NAME}rc" + (intNum+1)
            }
            println "JOBMON_NEW_RC_TAG=${JOBMON_NEW_RC_TAG}"

            withCredentials([gitUsernamePassword(credentialsId: 'svcscicompci')]) {
                sh '''#!/bin/bash
                    git clone --branch ${BRANCH_TYPE}/${BRANCH_NAME} ${STASH_URL} ${BRANCH_NAME}
                    cd ${BRANCH_NAME}
                    git tag -a ${JOBMON_NEW_RC_TAG} -m "Tag generated by ${JOB_BASE_NAME} on ${BRANCH_TYPE}/${BRANCH_NAME}"
                    git push origin ${JOBMON_NEW_RC_TAG}
                   '''
            }
          } else {
            error("Build Python Distribution is stopped due to invalid Branch type (${BRANCH_TYPE}) and/or Branch Name(${BRANCH_NAME})! Need to be release/major.minor.patch")
          } // end branch checking

          // recheck out the branch to entirely capture the tag update above
          checkout([
            $class: 'GitSCM',
            branches: [[name: params.BRANCH_TO_BUILD]],
            userRemoteConfigs: scm.userRemoteConfigs
          ])

          // Build Python package and publish to Pypi
          // Artifactory user with write permissions
          withCredentials([usernamePassword(credentialsId: 'artifactory-docker-scicomp',
                                            usernameVariable: 'REG_USERNAME',
                                            passwordVariable: 'REG_PASSWORD')]) {
            sh '''#!/bin/bash
                  # should always find the new tag, otherwise err out
                  if [ ! $(git tag -l ${JOBMON_NEW_RC_TAG}) ]
                  then
                    echo "New tag ${JOBMON_NEW_RC_TAG} not found, the build aborted!"
                    exit 1
                  fi
                  . ${WORKSPACE}/ci/deploy_utils.sh
                  upload_python_dist \
                      ${WORKSPACE} \
                      $REG_USERNAME \
                      $REG_PASSWORD \
                      "${ACTIVATE}"
               '''
          } // end credentials
          env.JOBMON_VERSION_DEPLOYED = sh (
            script: '''#!/bin/bash
                       cat ${WORKSPACE}/jobmon_version_deployed.txt
                    ''',
            returnStdout: true
          ).trim()
          println "Jobmon ${JOBMON_VERSION_DEPLOYED} has been deployed!"

        } // end script
      } // end steps
    } // end Build Python Distribution stage
  } // end stages
  post {
    always {
      // Delete the workspace directory.
      deleteDir()
    } // End always
  } // End post
} // End pipeline
