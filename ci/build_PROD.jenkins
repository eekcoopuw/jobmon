pipeline {
  agent {
    label "slurm"
  }
  parameters {
    listGitBranches(
      branchFilter: '.*',
      credentialsId: 'jenkins',
      defaultValue: '',
      name: 'BRANCH_TO_BUILD',
      quickFilterEnabled: false,
      remoteURL: 'ssh://git@stash.ihme.washington.edu:7999/scic/jobmon.git',
      selectedValue: 'DEFAULT',
      sortMode: 'NONE',
      tagFilter: '*',
      type: 'PT_BRANCH'
    )
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '30'))
  } // End options
  environment {
    // Jenkins commands run in separate processes, so need to activate the environment to run nox.
    ACTIVATE = ". /homes/svcscicompci/miniconda3/bin/activate base"
    STASH_URL = "https://stash.ihme.washington.edu/scm/scic/jobmon.git"
  } // End environment
  stages {
    stage('Remote Checkout Repo') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: params.BRANCH_TO_BUILD]],
          userRemoteConfigs: scm.userRemoteConfigs
        ])
      } // End step
    } // End remote checkout repo stage
    stage ('Build Python Distribution') {
      steps {
        script {
          def branch_sections = "${GIT_BRANCH}".split('/')
          env.BRANCH_TYPE = branch_sections[branch_sections.length-2]
          env.BRANCH_NAME = branch_sections[branch_sections.length-1]
		  if (branch_type == 'release') {
            withCredentials([gitUsernamePassword(credentialsId: 'svcscicompci')]) {
                sh '''#!/bin/bash
                    git clone --branch ${BRANCH_TYPE}/${BRANCH_NAME} ${STASH_URL} ${BRANCH_NAME}
                    cd ${BRANCH_NAME}
                    HEAD_COMMIT_ID=$(git rev-parse HEAD)
                    echo "HEAD_COMMIT_ID=$HEAD_COMMIT_ID"
                    TAG_ON_HEAD=$(git describe --tags $HEAD_COMMIT_ID)
                    echo "TAG_ON_HEAD=$TAG_ON_HEAD"
                    if [[ $TAG_ON_HEAD =~  ^${BRANCH_NAME}(\\.0)*rc[0-9]+$ ]]; then
                      IFS='rc' read -r -a array <<< "$TAG_ON_HEAD"
                      PROD_TAG_TO_USE=${array[0]}
                      echo "PROD_TAG_TO_USE=${PROD_TAG_TO_USE}"
                      git tag -a ${PROD_TAG_TO_USE} -m "Tag generated by ${JOB_BASE_NAME} on ${BRANCH_TYPE}/${BRANCH_NAME}"
                      git push origin ${PROD_TAG_TO_USE}
                    else
                      echo "The HEAD of the branch ${GIT_BRANCH} has no RC tag found. No PROD tag can be assigned. Aborted!"
                      exit 1
                    fi
                   '''
            }
          } else {
            error("Build Python Distribution is stopped due to invalid Branch type (${BRANCH_TYPE}) and/or Branch Name(${BRANCH_NAME})! Need to be release/major.minor.patch")
          } // end branch checking

          // recheck out the branch to entirely capture the tag update above
          checkout([
            $class: 'GitSCM',
            branches: [[name: params.BRANCH_TO_BUILD]],
            userRemoteConfigs: scm.userRemoteConfigs
          ])

          // Build Python package and publish to Pypi
          // Artifactory user with write permissions
          withCredentials([usernamePassword(credentialsId: 'artifactory-docker-scicomp',
                                            usernameVariable: 'REG_USERNAME',
                                            passwordVariable: 'REG_PASSWORD')]) {
            sh '''#!/bin/bash
                  # should always find the new tag, otherwise err out
                  if [ ! $(git tag -l ${JOBMON_PROD_TAG}) ]
                  then
                    echo "New tag ${JOBMON_PROD_TAG} not found, the build aborted!"
                    exit 1
                  fi
                  . ${WORKSPACE}/ci/deploy_utils.sh
                  upload_python_dist \
                      ${WORKSPACE} \
                      $REG_USERNAME \
                      $REG_PASSWORD \
                      "${ACTIVATE}"
               '''
          } // end credentials
          env.JOBMON_VERSION_DEPLOYED = sh (
            script: '''#!/bin/bash
                       cat ${WORKSPACE}/jobmon_version_deployed.txt
                    ''',
            returnStdout: true
          ).trim()
          println "Jobmon ${JOBMON_VERSION_DEPLOYED} has been deployed!"

        } // end script
      } // end steps
    } // end Build Python Distribution stage
  } // end stages
  post {
    always {
      // Delete the workspace directory.
      deleteDir()
    } // End always
  } // End post
} // End pipeline