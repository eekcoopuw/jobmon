pipeline {
  agent {
    label "slurm"
  }
  parameters {
    listGitBranches(
      branchFilter: '.*',
      credentialsId: 'jenkins',
      defaultValue: '',
      name: 'BRANCH_TO_BUILD',
      quickFilterEnabled: false,
      remoteURL: 'ssh://git@stash.ihme.washington.edu:7999/scic/jobmon.git',
      selectedValue: 'DEFAULT',
      sortMode: 'NONE',
      tagFilter: '*',
      type: 'PT_BRANCH'
    )
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '30'))
  } // End options
  environment {
    // Jenkins commands run in separate processes, so need to activate the environment to run nox.
    ACTIVATE = ". /homes/svcscicompci/miniconda3/bin/activate base"
    STASH_URL = "https://stash.ihme.washington.edu/scm/scic/jobmon.git"
    PYPI_URL = "https://artifactory.ihme.washington.edu:443/artifactory/pypi-shared"
  } // End environment
  stages {
    stage('Remote Checkout Repo') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: params.BRANCH_TO_BUILD]],
          userRemoteConfigs: scm.userRemoteConfigs
        ])
      } // End step
    } // End remote checkout repo stage
    stage ('Build Python Distribution') {
      steps {
        script {
          def branch_sections = "${GIT_BRANCH}".split('/')
          env.BRANCH_TYPE = branch_sections[branch_sections.length-2]
          env.BRANCH_NAME = branch_sections[branch_sections.length-1]
		  if (branch_type == 'release') {
            if (!("${BRANCH_NAME}" ==~ /\d+\.\d+\.\d+/)) {
              error("Branch Name ${BRANCH_NAME} is not a valid semver in complete major.minor.patch format. Build aborted!")
            }
            withCredentials([gitUsernamePassword(credentialsId: 'svcscicompci')]) {
                sh '''#!/bin/bash
                    RES_CURL=$(curl -X GET $PYPI_URL/jobmon/$BRANCH_NAME/)
                    if [[ ! $RES_CURL == *"not exist"* ]]; then
                        echo "Artifact ${BRANCH_NAME} found existing via curl: $PYPI_URL/jobmon/$BRANCH_NAME/"
                        echo "${BRANCH_NAME}" > "${WORKSPACE}/existing_prod_artifact.txt"
                    else
                        echo "" > "${WORKSPACE}/existing_prod_artifact.txt"
                        git clone --branch ${BRANCH_TYPE}/${BRANCH_NAME} ${STASH_URL} ${BRANCH_NAME}
                        if [ $? -ne 0 ]; then echo "git clone failed"; exit 1; fi
                        cd ${BRANCH_NAME}
                        HEAD_COMMIT_ID=$(git rev-parse HEAD)
                        echo "HEAD_COMMIT_ID=$HEAD_COMMIT_ID"
                        TAG_ON_HEAD=$(git describe --tags $HEAD_COMMIT_ID)
                        echo "TAG_ON_HEAD=$TAG_ON_HEAD"
                        if [[ $TAG_ON_HEAD =~ ^${BRANCH_NAME}rc[0-9]+$ ]]; then
                            git tag -a ${BRANCH_NAME} -m "Tag generated by ${JOB_BASE_NAME} on ${BRANCH_TYPE}/${BRANCH_NAME}"
                            if [ $? -ne 0 ]; then echo "git tag failed"; exit 1; fi
                            git push origin ${BRANCH_NAME}
                            if [ $? -ne 0 ]; then echo "git push failed"; exit 1; fi
                        else
                          echo "The HEAD of the branch ${GIT_BRANCH} has no RC tag found. No PROD tag can be assigned. Aborted!"
                          exit 1
                        fi
                    fi
                   '''
                env.EXISTING_PROD_ARTIFACT = sh (
                  script: '''#!/bin/bash
                             cat "${WORKSPACE}/existing_prod_artifact.txt"
                          ''',
                  returnStdout: true
                ).trim()
            }
          } else {
            error("The branch type (${BRANCH_TYPE}) must be 'release' for PROD deployment. Build aborted!")
          } // end branch checking

          if ("${EXISTING_PROD_ARTIFACT}".length() > 0) {
              println "Artifact ${EXISTING_PROD_ARTIFACT} already existing. Upload skipped!"
          } else {
              // recheck out the branch to entirely capture the tag update above
              checkout([
                $class: 'GitSCM',
                branches: [[name: params.BRANCH_TO_BUILD]],
                userRemoteConfigs: scm.userRemoteConfigs
              ])

              // Build Python package and publish to Pypi
              // Artifactory user with write permissions
              withCredentials([usernamePassword(credentialsId: 'artifactory-docker-scicomp',
                                                usernameVariable: 'REG_USERNAME',
                                                passwordVariable: 'REG_PASSWORD')]) {
                sh '''#!/bin/bash
                      . ${WORKSPACE}/ci/deploy_utils.sh
                      upload_python_dist \
                          ${WORKSPACE} \
                          $REG_USERNAME \
                          $REG_PASSWORD \
                          "${ACTIVATE}"
                   '''
              } // end credentials
              env.JOBMON_VERSION_DEPLOYED = sh (
                script: '''#!/bin/bash
                           cat ${WORKSPACE}/jobmon_version_deployed.txt
                        ''',
                returnStdout: true
              ).trim()
              println "Jobmon ${JOBMON_VERSION_DEPLOYED} has been deployed!"
          } // end if
        } // end script
      } // end steps
    } // end Build Python Distribution stage
  } // end stages
  post {
    always {
      // Delete the workspace directory.
      deleteDir()
    } // End always
  } // End post
} // End pipeline